// 给你一个整数数组 cost ，其中 cost[i] 是从楼梯第 i 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。

// 你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯。

// 请你计算并返回达到楼梯顶部的最低花费。



// 示例 1：

// 输入：cost = [10,15,20]
// 输出：15
// 解释：你将从下标为 1 的台阶开始。
// - 支付 15 ，向上爬两个台阶，到达楼梯顶部。
// 总花费为 15 。
// 示例 2：

// 输入：cost = [1,100,1,1,1,100,1,1,100,1]
// 输出：6
// 解释：你将从下标为 0 的台阶开始。
// - 支付 1 ，向上爬两个台阶，到达下标为 2 的台阶。
// - 支付 1 ，向上爬两个台阶，到达下标为 4 的台阶。
// - 支付 1 ，向上爬两个台阶，到达下标为 6 的台阶。
// - 支付 1 ，向上爬一个台阶，到达下标为 7 的台阶。
// - 支付 1 ，向上爬两个台阶，到达下标为 9 的台阶。
// - 支付 1 ，向上爬一个台阶，到达楼梯顶部。
// 总花费为 6 。


// 提示：

// 2 <= cost.length <= 1000
// 0 <= cost[i] <= 999


/**
 * @param {number[]} cost
 * @return {number}
 */
var minCostClimbingStairs = function (cost) {
  let sum = 0;
  // 假设已经到达栈顶,且花费最小,
  // 栈顶的前一步, 仍然是花费最小的, 即选择最后两个元素中最小的一个.
  // for (let i = cost.length - 1; i > 0; i--) {
  //   if (i - 1 >= 0) {
  //     if (cost[i - 1] >= cost[i]) {

  //     }
  //   }
  // }

  let length = cost.length;
  if (length === 2) {
    return Math.min(cost[0], cost[1]);
  }

  for (let j = 0; j < cost.length;) {
    if (1 == 1) {
      sum = sum + cost[j];
    }
  }
  if (cost.length - j <= 2) {
    return sum;
  }
};

// let cost = [10, 15, 20];
// 预期: 15

let cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1];
// 0       2     4       6  7       9
// 1       1     1       1  1       1  = 6
console.log("结果:", minCostClimbingStairs(cost));