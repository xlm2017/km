# 哈希表

映射, 记忆化, 记忆前面迭代的特定的特征



# 双指针技巧
  
  # 一次for循环或者迭代, 用两个指针干活, 
  # 比一个指针效率高一些, 降低一个指数级的时间复杂度
  O(N^2) ==> O(N)   
  O(N^3) ==> O(N^2)


 # 个人总结的浅显的应用场景技巧

   # 链表数据结构的问题
   构造一个节点, 循环访问节点

   # 数组结构的问题
   for循环的基础上, 头尾两个指针, 结合条件逼近指针.
   <!-- 快速排序 -->

   for循环基础上, 再使用一个指针, 或者嵌套循环
   <!-- 最长递增子序列 -->
  



# 回溯, 动态规划, 贪心

什么样的问题适合动态规划求解 ?

一个模型, 三个特征.

多阶段决策最优解模型.

 # 回溯: 穷举搜索, 最核心的解法

 # 动态规划: 回溯算法中存在重复求解的问题, 回溯 + 备忘录,避免重复子问题 
    或者观察三个特征
      存在最优子结构, 
      无后效性(后面的求解, 不用关心前面的值),
      存在重复子问题,

    解决问题的过程, 需要经历多个决策阶段.每个决策阶段都对应着一组状态. 
    然后经过这组决策序列, 能够产生最终期望求解的最优值.

    思路:
      1.  状态转移表法, 二维/三维/思维等数组表,  递归树, 观察是否存在重复子问题, 以及子问题是如何产生的. 
      
      2.  状态转移方程法, 某个问题如何通过子问题来递归求解.大致如下:
          回溯算法实现
          定义状态
          画递归树
          找重复子问题
          画状态转移表
          根据地推关系填表
          将填表过程翻译成代码
  
        找最优子结构 --> 写状态转移方程 --> 将状态转移方程翻译成代码.

  # 贪心
    实际算是动态规划的算法的一种特殊情况, 需要满足三个条件
    最优子结构
    无后效性
    贪心选择性: 通过局部最优的选择, 能产生全局的最优选择. 每个阶段, 我们都选择当前看起来最优的决策, 所有的阶段的决策完成之后, 最终由这些局部最优解构成全局最优解.
 

# 分治



# 记忆划搜索
<!-- 就是自顶向下的递归，动态规划的另外一种实现方式。 -->


# 链表, 树,  图


# 栈, 单调栈
寻找结果集的单调性, 过滤掉一些不符合条件的结果


# 队列





# 动态规划的本质，就是原题可以拆分成大量的子问题，每个子问题的解形成了解空间，而目标就是在解空间中找某个指标达到极值的解（称之为最优解）。 就用动态规划问题的通用方式来求解。

# 第1步：确认子问题/解空间
遍历所有两堵墙，形成了O(N^2)个子问题。 在这O(N^2)个解里，肯定有一个是最优解。

# 第2步：避免重复计算
动态规划本质上就是避免重复计算。具体有两种途径：

# 算过的不要再算。 
实现这个目标的方法是用简单的索引（比如数组下标之类的）将每个子问题编码，这样能快速判断出一个子问题是否已经算过，如果算过就直接获得答案。 不过本题O(N^2)的暴力算法其实已经不包括任何重复问题了。

# 不用算的不要算。 
实现这个目标的方法是寻找子问题之间的关系，将子问题以某种方式排列起来，然后快速排除掉大量的、肯定不是最终答案的子问题。 

作者：seedjyh
链接：https://leetcode.cn/problems/container-with-most-water/solutions/326370/shi-jian-fu-za-du-onkong-jian-fu-za-du-o1dong-tai-/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。



# 特殊的双指针  -  滑动窗口

