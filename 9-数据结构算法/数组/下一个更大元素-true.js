

/**
* @param {number[]} nums1
* @param {number[]} nums2
* @return {number[]}
*/
var nextGreaterElement = function (nums1, nums2) {
  let res = []
  let stack = [nums2.length - 1]
  let hash = {}
  // 最后一个元素右侧没有元素, 所以为 -1
  hash[nums2[nums2.length - 1]] = -1

  console.log("nums2.length - 2:", nums2.length - 2);
  // 从倒数第二个开始遍历
  for (let j = nums2.length - 2; j >= 0; j--) {
    console.log("当前迭代:", nums2[j])
    for (let i = stack.length - 1; i >= 0; i--) {
      console.log("当前值:", nums2[j]);
      console.log("栈顶值:", nums2[stack[i]]);
      if (nums2[j] < nums2[stack[i]]) {
        // 当前遍历的值 小于 栈顶元素
        hash[nums2[j]] = nums2[stack[i]];
        stack.push(j);
        console.log("栈加 变化:", stack);
        break;
      } else {
        stack.pop()
        console.log("栈减 变化:", stack);
        continue;
      }
      console.log("\n");
    }
    if (!stack.length) {
      hash[nums2[j]] = -1
      stack.push(j);
    }

  }

  console.log("计算的hash:", hash)

  for (let j = 0; j < nums1.length; j++) {
    res.push(hash[nums1[j]] || - 1)
  }

  return res;
};


let nums1 = [4, 1, 2];
let nums2 = [1, 3, 4, 2];
// [-1,3,-1]


// nums1 = [1, 3, 5, 2, 4];
// nums2 = [6, 5, 4, 3, 2, 1, 7];
// [7,-1,-1,-1,-1]  // 错误
// [7,7,7,7,7]      



// nums1 = [137, 59, 92, 122, 52, 131, 79, 236, 94, 171, 141, 86, 169, 199, 248, 120, 196, 168, 77, 71, 5, 198, 215, 230, 176, 87, 189, 206, 115, 76, 13, 216, 197, 26, 183, 54, 250, 27, 109, 140, 147, 25, 96, 105, 30, 207, 241, 8, 217, 40, 0, 35, 221, 191, 83, 132, 9, 144, 12, 91, 175, 65, 170, 149, 174, 82, 102, 167, 62, 70, 44, 143, 10, 153, 160, 142, 188, 81, 146, 212, 15, 162, 103, 163, 123, 48, 245, 116, 192, 14, 211, 126, 63, 180, 88, 155, 224, 148, 134, 158, 119, 165, 130, 112, 166, 93, 125, 1, 11, 208, 150, 100, 106, 194, 124, 2, 184, 75, 113, 104, 18, 210, 202, 111, 84, 223, 173, 238, 41, 33, 154, 47, 244, 232, 249, 60, 164, 227, 253, 56, 157, 99, 179, 6, 203, 110, 127, 152, 252, 55, 185, 73, 67, 219, 22, 156, 118, 234, 37, 193, 90, 187, 181, 23, 220, 72, 255, 58, 204, 7, 107, 239, 42, 139, 159, 95, 45, 242, 145, 172, 209, 121, 24, 21, 218, 246, 49, 46, 243, 178, 64, 161, 117, 20, 214, 17, 114, 69, 182, 85, 229, 32, 129, 29, 226, 136, 39, 36, 233, 43, 240, 254, 57, 251, 78, 51, 195, 98, 205, 108, 61, 66, 16, 213, 19, 68, 237, 190, 3, 200, 133, 80, 177, 97, 74, 138, 38, 235, 135, 186, 89, 201, 4, 101, 151, 31, 228, 231, 34, 225, 28, 222, 128, 53, 50, 247]
// nums2 = [137, 59, 92, 122, 52, 131, 79, 236, 94, 171, 141, 86, 169, 199, 248, 120, 196, 168, 77, 71, 5, 198, 215, 230, 176, 87, 189, 206, 115, 76, 13, 216, 197, 26, 183, 54, 250, 27, 109, 140, 147, 25, 96, 105, 30, 207, 241, 8, 217, 40, 0, 35, 221, 191, 83, 132, 9, 144, 12, 91, 175, 65, 170, 149, 174, 82, 102, 167, 62, 70, 44, 143, 10, 153, 160, 142, 188, 81, 146, 212, 15, 162, 103, 163, 123, 48, 245, 116, 192, 14, 211, 126, 63, 180, 88, 155, 224, 148, 134, 158, 119, 165, 130, 112, 166, 93, 125, 1, 11, 208, 150, 100, 106, 194, 124, 2, 184, 75, 113, 104, 18, 210, 202, 111, 84, 223, 173, 238, 41, 33, 154, 47, 244, 232, 249, 60, 164, 227, 253, 56, 157, 99, 179, 6, 203, 110, 127, 152, 252, 55, 185, 73, 67, 219, 22, 156, 118, 234, 37, 193, 90, 187, 181, 23, 220, 72, 255, 58, 204, 7, 107, 239, 42, 139, 159, 95, 45, 242, 145, 172, 209, 121, 24, 21, 218, 246, 49, 46, 243, 178, 64, 161, 117, 20, 214, 17, 114, 69, 182, 85, 229, 32, 129, 29, 226, 136, 39, 36, 233, 43, 240, 254, 57, 251, 78, 51, 195, 98, 205, 108, 61, 66, 16, 213, 19, 68, 237, 190, 3, 200, 133, 80, 177, 97, 74, 138, 38, 235, 135, 186, 89, 201, 4, 101, 151, 31, 228, 231, 34, 225, 28, 222, 128, 53, 50, 247]

// 预期
// [236,92,122,131,131,236,236,248,171,199,169,169,199,248,250,196,198,198,198,198,198,215,230,250,189,189,206,216,216,216,216,250,250,183,250,250,253,109,140,147,207,96,105,207,207,241,245,217,221,221,35,221,245,212,132,144,144,175,91,175,188,170,174,174,188,102,167,188,70,143,143,153,153,160,188,188,212,146,212,245,162,163,163,245,245,245,249,192,211,211,224,180,180,224,155,224,238,158,158,165,165,166,166,166,208,125,208,11,208,210,194,106,194,210,184,184,210,113,210,210,210,223,223,223,223,238,238,244,154,154,244,244,249,249,253,164,227,253,255,157,179,179,203,203,252,127,152,252,255,185,219,219,219,234,156,234,234,255,193,220,187,220,220,220,255,255,-1,204,239,107,239,242,139,159,242,242,242,246,172,209,218,218,218,218,246,254,243,243,254,214,161,214,214,214,229,114,182,182,229,229,233,129,226,226,233,233,233,233,240,240,254,-1,251,-1,195,195,205,205,213,213,66,213,213,237,68,237,247,200,200,235,177,177,235,138,138,235,235,247,186,201,201,228,101,151,228,228,231,247,225,247,222,247,247,247,247,-1]

// 错误

console.log(nextGreaterElement(nums1, nums2));




// 最佳代码

/**
 * @param {number[]} nums1
 * @param {number[]} nums2
 * @return {number[]}
 */
var nextGreaterElement2 = function (nums1, nums2) {
  let stack = [], map = new Map();
  for (let i = nums2.length - 1; i >= 0; i--) {
    while (stack.length && nums2[i] > stack[stack.length - 1]) {
      stack.pop()
    }
    map.set(nums2[i], stack.length ? stack[stack.length - 1] : -1);
    stack.push(nums2[i]);
  }
  let s = nums1.map(x => map.get(x))
  return s
};


// 单调栈用途不太广泛，只处理一种典型的问题，叫做 Next Greater Element。本文用讲解单调队列的算法模版解决这类问题，并且探讨处理「循环数组」的策略。

// 首先，讲解 Next Greater Number 的原始问题：给你一个数组，返回一个等长的数组，对应索引存储着下一个更大元素，如果没有更大的元素，就存 -1。不好用语言解释清楚，直接上一个例子：

// 给你一个数组 [2,1,2,4,3]，你返回数组 [4,2,4,-1,-1]。

// 作者：labuladong
// 链接：https://leetcode.cn/problems/next-greater-element-i/solutions/8877/dan-diao-zhan-jie-jue-next-greater-number-yi-lei-w/
// 来源：力扣（LeetCode）
// 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。





// 首先，计算机的内存都是线性的，没有真正意义上的环形数组，但是我们可以模拟出环形数组的效果，一般是通过 % 运算符求模（余数），获得环形特效：

// int[] arr = {1,2,3,4,5};
// int n = arr.length, index = 0;
// while (true) {
//     print(arr[index % n]);
//     index++;
// }

// 作者：labuladong
// 链接：https://leetcode.cn/problems/next-greater-element-i/solutions/8877/dan-diao-zhan-jie-jue-next-greater-number-yi-lei-w/
// 来源：力扣（LeetCode）
// 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。



// 单调栈：

// 倒行逆施：倒序遍历；

// 反正我觉得这里的逆向入栈不是因为保证正向出栈，而是为了在将当前元素压入栈时，此时栈顶元素刚好为比当前元素大的最近元素。

// 正序的话，是在出栈的时候将答案写入哈希表，并且key是栈顶元素，value是当前遍历值。 逆序的话，是在进栈的时候将答案写入哈希表，并且key是当前遍历值，value是栈顶元素



// 优胜劣汰：进栈时先比自己菜的踢出去。


// 时间复杂度 (n + m)