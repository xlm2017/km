


// 在未排序序列中找到最小（大）元素，存放到排序序列的起始位置
// 从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。
// 重复第二步，直到所有元素均排序完毕。

// 简单排序的思想：遍历取出待排序元素的最大值或者最小值，依次放入序列中，这样序列就有序了。简单排序的重点是：从待排序的元素中取出最大值或者最小值。


// 简单选择排序,  也称为  直接选择排序,   不稳定


function selectionSort (arr) {
  var len = arr.length;
  var minIndex, temp;
  for (var i = 0; i < len - 1; i++) {
    minIndex = i;
    for (var j = i + 1; j < len; j++) {
      if (arr[j] < arr[minIndex]) {     // 寻找最小的数
        minIndex = j;                 // 将最小数的索引保存
      }
    }
    temp = arr[i];
    arr[i] = arr[minIndex];
    arr[minIndex] = temp;
  }
  console.log(arr);
}
let arr1 = [4, 23, 100, 9, 7, 49, 36, 57];
selectionSort(arr1);


// 简单选择排序的总结
//         简单选择排序的时间复杂度是O(n²)，其空间复杂度是O(1)，是一种不稳定算法。

//         时间复杂度O(n²)：第一个元素需要比较n-1次，第二个需要比较n-2次，以此类推，则1+2+3+...+(n-2)+（n-1）=n*(n-1)/2，则时间复杂度为n²。

//         空间复杂度O(1)：只是需要一个保存索引和临时变量的内存，不会变化，所以为1。

//         不稳定算法：是不稳定算法，在交换的过程中可能会改变相同元素的相对位置，例如：{4，6,3,4,2}，在序列中4和2交换位置，则4的相对位置发生变化，则是不稳定算法。



// 稳定性
// 选择排序是给每个位置选择当前元素最小的，比如给第一个位置选择最小的，在剩余元素里面给第二个元素选择第二小的，依次类推，
// 直到第n-1个元素，第n个元素不用选择了，因为只剩下它一个最大的元素了。那么，在一趟选择，如果一个元素比当前元素小，
// 而该小的元素又出现在一个和当前元素相等的元素后面，那么交换后稳定性就被破坏了。
// 举个例子，序列5 8 5 2 9，
// 我们知道第一遍选择第1个元素5会和2交换，那么原序列中两个5的相对前后顺序就被破坏了，所以选择排序是一个不稳定的排序算法。