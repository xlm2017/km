// 快速排序

let arr = [5, 4, 3, 8, 7, 2, 6, 1, 9];

// 冒泡排序  交换排序

// 是对冒泡排序算法的一种改进。
// 多次比较和交换

// 快速排序算法通过多次比较和交换来实现排序，其排序流程如下：

// (1)首先设定一个分界值，通过该分界值将数组分成左右两部分。

// (2)将大于或等于分界值的数据集中到数组右边，小于分界值的数据集中到数组的左边。
// 此时，左边部分中各元素都小于分界值，而右边部分中各元素都大于或等于分界值。

// (3)然后，左边和右边的数据可以独立排序。对于左侧的数组数据，又可以取一个分界值，
// 将该部分数据分成左右两部分，同样在左边放置较小值，右边放置较大值。右侧的数组数据也可以做类似处理。

// (4)重复上述过程，可以看出，这是一个递归定义。通过递归将左侧部分排好序后，再递归排好右侧部分的顺序。
// 当左、右两个部分各数据排序完成后，整个数组的排序也就完成了。 


function quick_sort (array) {
  // 定义基准值, 用于将数组分割为两个部分
  let base = array[0];
}

console.log("排序前:", arr);
quick_sort(arr);
console.log("排序结果:", arr);



// 时间复杂度
// 当数据有序时，以第一个关键字为基准分为两个子序列，前一个子序列为空，此时执行效率最差。

// 而当数据随机分布时，以第一个关键字为基准分为两个子序列，两个子序列的元素个数接近相等，此时执行效率最好。

// 所以，数据越随机分布时，快速排序性能越好；数据越接近有序，快速排序性能越差。

// 3、时间复杂度
// 快速排序在每次分割的过程中，需要 1 个空间存储基准值。而快速排序的大概需要 logN次的分割处理，所以占用空间也是 logN 个。

// 4、算法稳定性
// 在快速排序中，相等元素可能会因为分区而交换顺序，所以它是不稳定的算法。


