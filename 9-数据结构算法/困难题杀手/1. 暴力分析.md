<!--
 * @Description: 
 * @Author: xlm
 * @Date: 2023-04-19 15:43:57
 * @LastEditTime: 2023-04-19 17:30:57
 * @LastEditors: xlm
-->




暴力穷举分析


// '.' 匹配任意单个字符
// '*' 匹配零个或多个前面的那一个元素

匹配的情况

s  a*    a.     ab*    ab.     ab*    

p  a     ab     abb    abc     a 


继续分解

* 的情况

abc*d

abd
abccd
abcccd
abcccccccccccd



继续分解, 最小简化表现本质

a*b

b
ab
aab
aaaaaaaaaab

拆解了一个子问题, 

即如何实现上面这个本质 ? 

暂不考虑原文字, 只关注这一个点


字符串是否相等 ?   通常是如何比较的 ?

1. 比较位数, 不相等结束, 相等的话, for循环长度一位位的比.

本题中, 明显长度不相等, 字符串也可能是同样的意思, 所以需要新的比较方式.


容易想到, 字符串是个动态变化的串, 任意串, 每变化一次, 都需要重新比较一下, 

但是对于每一个新增的字符串的比较, 其前面的部分是确定的, 如果前面不确定, 则没有比较的必要性了.


体现出来基于动态的推导的比较思想, 思考模型为动态规划.


设 s的长度为 i
   p的长度为 j
   且首位字符串不可能为*

  如果 s[0] === p[0], 继续

  如果 s[0] !== p[0] 例如 a*b   b , 是否相等取决于 s的首位后面是否存在 *

  确认 * 存在1种动作, 1. 擦除动作, 如果*前面的字符与 p 的当前比较下标位置不相等, 则擦除前面的那个字符,
   
  同时这个 * 也销毁了, 再用字符串新的下标位置进行比较.



  aaaaaaaaaab   a*b 

  确认 * 存在1种动作,  1. 如果 * 没有被消耗掉, *可以无限使用, 只到不可用



  将上述逻辑关键部分用 伪代码表现出来

  ```js

  let i = s.length - 1 
  let j = s.length - 1 

  // 使用二维数组表现一种有两个对象共同决定的事件, 即 两个子串是否匹配

  // dingyi 
  let dp = new Array(s.length).fill(new Array(p.length));
  // dp[i][j] 代表一种状态, 子串0-i 与 子串0-j 比较

  ```

  将两个整体的字符串转化为各位子串的比较, 将一个整体的问题拆分成了一个子问题.


  两个字符串的比较, 从常规的方式转化为, 两个子串基于特殊规则动态的比较.


  ```js

   


  ```