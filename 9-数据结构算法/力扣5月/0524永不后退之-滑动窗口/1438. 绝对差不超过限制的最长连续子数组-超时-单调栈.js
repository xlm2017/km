


// 给你一个整数数组 nums ，和一个表示限制的整数 limit，请你返回最长连续子数组的长度，该子数组中的任意两个元素之间的绝对差必须小于或者等于 limit 。

// 如果不存在满足条件的子数组，则返回 0 。



// 示例 1：

// 输入：nums = [8,2,4,7], limit = 4
// 输出：2 
// 解释：所有子数组如下：
// [8] 最大绝对差 |8-8| = 0 <= 4.
// [8,2] 最大绝对差 |8-2| = 6 > 4. 
// [8,2,4] 最大绝对差 |8-2| = 6 > 4.
// [8,2,4,7] 最大绝对差 |8-2| = 6 > 4.
// [2] 最大绝对差 |2-2| = 0 <= 4.
// [2,4] 最大绝对差 |2-4| = 2 <= 4.
// [2,4,7] 最大绝对差 |2-7| = 5 > 4.
// [4] 最大绝对差 |4-4| = 0 <= 4.
// [4,7] 最大绝对差 |4-7| = 3 <= 4.
// [7] 最大绝对差 |7-7| = 0 <= 4. 
// 因此，满足题意的最长子数组的长度为 2 。
// 示例 2：

// 输入：nums = [10,1,2,4,7,2], limit = 5
// 输出：4 
// 解释：满足题意的最长子数组是 [2,4,7,2]，其最大绝对差 |2-7| = 5 <= 5 。
// 示例 3：

// 输入：nums = [4,2,2,2,4,4,2,2], limit = 0
// 输出：3


// 提示：

// 1 <= nums.length <= 10^5
// 1 <= nums[i] <= 10^9
// 0 <= limit <= 10^9


/**
 * @param {number[]} nums
 * @param {number} limit
 * @return {number}
 */
var longestSubarray = function (nums, limit) {

  // 抄---
  let len = nums.length, res = 0, l = 0, r = -1;
  // 单调队列：max为单调递减队列 存储窗口内最大值，min为单调增队列 存储窗口内最小值
  let max = [], min = [];
  while (++r < len) {
    // 扩大窗口 维护单调队列
    while (max.length > 0 && max[max.length - 1] < nums[r]) max.pop();
    while (min.length > 0 && min[min.length - 1] > nums[r]) min.pop();
    max.push(nums[r]);
    min.push(nums[r]);
    // 若当前窗口内极值差大于limit 左移窗口l边界
    while (max[0] - min[0] > limit) {
      if (nums[l] === max[0]) max.shift();
      if (nums[l] === min[0]) min.shift();
      l++;
    }
    // 维护窗口最大值
    res = Math.max(res, r - l + 1);
  }
  return res;

};


let nums = [8, 2, 4, 7], limit = 4;
// 2


console.log(longestSubarray(nums, limit));




// 使用滑动窗口，维护当前窗口的的最大值和最小值是解决这个问题的关键。

// 既然是维护，那就要考虑，当窗口扩大时，那来一个新的值是很容易知道是否是最大值或者是最小值，即维护起来是简单直观的。 
// 但是，当窗口减小时，假如从窗口出去的是最大值，或者是最小值，那么窗口缩小以后的最小值或者最大值是啥呢。
// 所以相对窗口增大再次判断最值不容易想出来。

// 实际上，这个维护窗口的最值问题，是一个非常经典的问题，归纳出来一种普遍认为比较好用的方法，就是使用单调队列。 
// 因为单调队列保持了队列中元素之间的固有的顺序，同时也维护了单调性。这样，当窗口减小时，我们非常容易知道下一个最值是多少。

// 但是，单调队列只能维护一种单调性，而题目又要求我们同时考虑最大值和最小值的差，
// 所以就用两个呗，后边的解决方法也就顺其自然了。