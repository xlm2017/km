
// 强缓存

Expires  // 到期, 有效期, 代表该资源的过期时间, 是一个GMT格式的标准时间     // 原型: expire
  服务端设置
  优: 
    // 1. 减少服务器重复大区磁盘文件的压力
    // 2. 省用户流量
  缺:
    // 1. 缓存过期以后, 服务器不管文件有没有变化, 都会再次请求服务器
    // 2. 缓存过期时间依赖于客户端的时间, 时间不准确或者被改动也会随之受到影响   
 
    // expires “不精准” 是因为它的值是一个绝对时间，而 max-age 与其相反却是一个相对时间

Cache-Control  // 

// Cache-Control  优先级更高  1.1增加的 (既可以出现在请求头, 也可以出现在响应头)
  服务端: 
   到期 
    max-age    :   在多少秒内有效, 是一个相对时间
    s-maxage   :   用于表示 cache服务器上 (比如 cache CDN, 缓存代理服务器 ) 的缓存的有效时间的, 并只对public缓存有效
    ...
    max-stale [=<seconds>]
    表明客户端愿意接收一个已经过期的资源。可以设置一个可选的秒数，表示响应不能已经过时超过该给定的时间。
    min-fresh =<seconds>
    表示客户端希望获取一个能在指定的秒数内保持其最新状态的响应。
    stale-while-revalidate =<seconds> 
    表明客户端愿意接受陈旧的响应，同时在后台异步检查新的响应。秒值指示客户愿意接受陈旧响应的时间长度。
    stale-if-error=<seconds> 
    表示如果新的检查失败，则客户愿意接受陈旧的响应。秒数值表示客户在初始到期后愿意接受陈旧响应的时间。
    重新验证和重新加载
    must-revalidate
    一旦资源过期（比如已经超过max-age），在成功向原始服务器验证之前，缓存不能用该资源响应后续请求。
    proxy-revalidate
    与must-revalidate作用相同，但它仅适用于共享缓存（例如代理），并被私有缓存忽略。
    immutable 
    表示响应正文不会随时间而改变。资源（如果未过期）在服务器上不发生改变，
    因此客户端不应发送重新验证请求头（例如If-None-Match或If-Modified-Since）来检查更新，即使用户显式地刷新页面。
    在Firefox中，immutable只能被用在 https:// transactions. 有关更多信息，请参阅这里。
    其他
    no-transform
    不得对资源进行转换或转变。Content-Encoding、Content-Range、Content-Type等HTTP头不能由代理修改。
    例如，非透明代理或者如Google's Light Mode可能对图像格式进行转换，以便节省缓存空间或者减少缓慢链路上的流量。no-transform指令不允许这样做。
    only-if-cached
    表明客户端只接受已缓存的响应，并且不要向原始服务器检查是否有更新的拷贝。

   可缓存性
    no-cache   :   不使用本地强缓存. 需要使用缓存协商.
    no-store   :   直接禁止浏览器缓存数据.
    public     :   可以被所有的用户缓存,包括终端用户和中间代理服务器.CDN
    privite    :   只能被终端用户的浏览器缓存.
  
  客户端:
    max-stale  :   表示客户端到代理服务器上拿缓存的时候,即使代理缓存过期了也不要紧, 只要过期时间在5秒之内,还是可以从代理中获取的.
    min-fresh  :   代理缓存过期5秒之前, 缓存有效. 
    only-if-cached 客户端只接受代理缓存,而不会接受原服务器的响应, 如果代理缓存无效, 直接返回504 ( gateway timeout )    

// 特点: 命中强缓存之后, 客户端不会再请求,直接从缓存中读取内容,并返回HTTP状态码 200


// 协商缓存  304

etag: '5c20abbd-e2e8' 
"<etag_value>"
实体标签唯一地表示所请求的资源。 它们是位于双引号之间的ASCII字符串（如“675af34563dc-tr34”）。
 没有明确指定生成ETag值的方法。 通常，使用内容的散列，最后修改时间戳的哈希值，或简单地使用版本号。 例如，MDN使用wiki内容的十六进制数字的哈希值。

// 资源的特定版本的标识符。这可以让缓存更高效，并节省带宽，因为如果内容没有改变，
// Web服务器不需要发送完整的响应。而如果内容发生了变化，使用ETag有助于防止资源的同时更新相互覆盖（“空中碰撞”）。

// 如果给定URL中的资源更改，则一定要生成新的Etag值。 因此Etags类似于指纹，也可能被某些服务器用于跟踪。 
// 比较etags能快速确定此资源是否变化，但也可能被跟踪服务器永久存留。

// 哈希值(hash values)是使用哈希函数(hash function)计算得到的值。哈希函数是是一种从任何一种数据中创建小的数字“指纹”的方法。
// 散列函数把消息或数据压缩成摘要，使得数据量变小，将数据的格式固定下来。就是根据数据内容计算得到相应的"摘要"，根据这个摘要可以区分该数据与其他数据。


每个文件有一个，改动文件了就变了，就是个文件hash，每个文件唯一，就像用webpack打包的时候，
每个资源都会有这个东西，如： app.js打包后变为 app.c20abbde.js，加个唯一hash，也是为了解决缓存问题。


// last-modified: Mon, 24 Dec 2018 09:49:49 GMT  //  GMT时间就是英国格林威治时间,也就是世界标准时间

last-modified：文件的修改时间，精确到秒

也就是说，每次请求返回来 response header 中的 etag和 last-modified，在下次请求时在 request header 就把这两个带上，
服务端把你带过来的标识进行对比，然后判断资源是否更改了，如果更改就直接返回新的资源，
和更新对应的response header的标识etag、last-modified。如果资源没有变，那就不变etag、last-modified，这时候对客户端来说，每次请求都是要进行协商缓存了，

发请求-->看资源是否过期-->过期-->请求服务器-->服务器对比资源是否真的过期-->没过期-->返回304状态码-->客户端用缓存的老资源。

这就是一条完整的协商缓存的过程。

当然，当服务端发现资源真的过期的时候，会走如下流程：

发请求-->看资源是否过期-->过期-->请求服务器-->服务器对比资源是否真的过期-->过期-->返回200状态码-->客户端如第一次接收该资源一样，记下它的cache-control中的max-age、etag、last-modified等。

所以协商缓存步骤总结：

请求资源时，把用户本地该资源的 etag 同时带到服务端，服务端和最新资源做对比。
如果资源没更改，返回304，浏览器读取本地缓存。
如果资源有更改，返回200，返回最新的资源。

response header中的etag、last-modified在客户端重新向服务端发起请求时，会在request header中换个key名：


// response header
etag: '5c20abbd-e2e8'
last-modified: Mon, 24 Dec 2018 09:49:49 GMT

// request header 变为
if-none-matched: '5c20abbd-e2e8'
if-modified-since: Mon, 24 Dec 2018 09:49:49 GMT



为什么要有etag？
你可能会觉得使用last-modified已经足以让浏览器知道本地的缓存副本是否足够新，为什么还需要etag呢？HTTP1.1中etag的出现
（也就是说，etag是新增的，为了解决之前只有If-Modified的缺点）主要是为了解决几个last-modified比较难解决的问题：

一些文件也许会周期性的更改，但是他的内容并不改变(仅仅改变的修改时间)，这个时候我们并不希望客户端认为这个文件被修改了，而重新get；

某些文件修改非常频繁，比如在秒以下的时间内进行修改，(比方说1s内修改了N次)，if-modified-since能检查到的粒度是秒级的，这种修改无法判断(或者说UNIX记录MTIME只能精确到秒)；

某些服务器不能精确的得到文件的最后修改时间。

怎么设置强缓存与协商缓存
后端服务器如nodejs:
res.setHeader('max-age': '3600 public')
res.setHeader(etag: '5c20abbd-e2e8')
res.setHeader('last-modified': Mon, 24 Dec 2018 09:49:49 GMT)


etag的作用

避免“空中碰撞”
在ETag和 If-Match 头部的帮助下，您可以检测到"空中碰撞"的编辑冲突。

例如，当编辑MDN时，当前的wiki内容被散列，并在响应中放入Etag：

ETag: "33a64df551425fcc55e4d42a148795d9f25f89d4
将更改保存到Wiki页面（发布数据）时，POST请求将包含有ETag值的If-Match头来检查是否为最新版本。

If-Match: "33a64df551425fcc55e4d42a148795d9f25f89d4"
如果哈希值不匹配，则意味着文档已经被编辑，抛出412前提条件失败错误。

缓存未更改的资源
ETag头的另一个典型用例是缓存未更改的资源。 如果用户再次访问给定的URL（设有ETag字段），显示资源过期了且不可用，客户端就发送值为ETag的If-None-Match header字段：

If-None-Match: "33a64df551425fcc55e4d42a148795d9f25f89d4"
服务器将客户端的ETag（作为If-None-Match字段的值一起发送）与其当前版本的资源的ETag进行比较，如果两个值匹配（即资源未更改），服务器将返回不带任何内容的304未修改状态，告诉客户端缓存版本可用（新鲜）。



其中强缓存包括Expires和Cache-Control，主要是在过期策略生效时应用的缓存。
弱缓存包括Last-Modified和ETag，是在协商策略后应用的缓存。
强弱缓存之间的主要区别在于获取资源时是否会发送请求。


no-cache并不是指不缓存文件，no-store才是指不缓存文件。no-cache仅仅是表明跳过强缓存，强制进入协商策略。

Cache-Control中的max-age指令用于指定缓存过期的相对时间，优先级高于Expires。Cache-Control指定为no-cache时，
由于no-cache相当于max-age:0,must-revalidate，所以都存在时优先级也是高于Expires。

如果Expires，Cache-Control: max-age，或 Cache-Control:s-maxage都没有在响应头中出现，并且设置了Last-Modified时，
那么浏览器默认会采用一个启发式的算法，即启发式缓存。通常会取响应头的Date_value - Last-Modified_value值的10%作为缓存时间


// 缓存新鲜度

我们先来认识下什么是缓存新鲜度，其和食品保质期概念大体相同，单位是时间长度。那么在浏览器中强缓存的保质期限怎么计算？

小册前面部分章节介绍强缓存时涉及时间单位的首部字段主要有两个：max-age 和 expires。而缓存的新鲜度公式如下：

缓存新鲜度 = max-age || (expires - date)
上述公式不难理解：当 max-age 存在时缓存新鲜度等于 max-age 的秒数，是一个时间单位，就像保质期为 6 个月一样。
当 max-age 不存在时，缓存新鲜度等于 expires - date 的值，expires 我们应该已经熟悉，它是一个绝对时间，表示缓存过期的时间，那么下面主要介绍下首部字段 date。

Date 表示创建报文的日期时间，可以理解为服务器（包含源服务器和代理服务器）返回新资源的时间，和 expires 一样是一个绝对时间，比如

date：Wed, 25 Aug 2021 13:52:55 GMT
那么过期时间（expires）减去创建时间（date）就可以计算出浏览器真实可以缓存的时间（默认已经转化为秒数），即缓存的保质期限（缓存新鲜度）。

至此，以上关于缓存新鲜度的计算公式便介绍完了，大家可以把缓存新鲜度看作是缓存的保质期（即浏览器可以缓存该资源的时间）后其公式便不难理解。









大公司里怎样开发和部署前端代码？

https://www.zhihu.com/question/20790576

所以，大公司的静态资源优化方案，基本上要实现这么几个东西：
配置超长时间的本地缓存                 
—— 节省带宽，提高性能采用内容摘要作为缓存更新依据      
—— 精确的缓存控制静态资源CDN部署                           
—— 优化网络请求更资源发布路径实现非覆盖式发布  —— 平滑升级   

先上线非覆盖式发布资源,css等, 后上线
用文件的摘要信息来对资源文件进行重命名，把摘要信息放到资源文件发布路径中，
这样，内容有修改的资源就变成了一个新的文件发布到线上，不会覆盖已有的资源文件。
上线过程中，先全量部署静态资源，再灰度部署页面，整个问题就比较完美的解决了。
