模块化的作用
模块化是为了处理全局污染和依赖管理混乱的问题

模块化
因为一开始js本身没有提供模块化的机制，所以才会衍生出commonJS、AMD、CMD和UMD这么多模块化规范。js在ES6时原生提供了import和export模块化机制

commonJS
定义
文件即模块，每个文件通过module来表示，用require来引用其他依赖，用module.exports来导出自身

机制
通过require去引用文件时，会将文件执行一遍后，将其执行结果通过浅克隆的方式，写入全局内存。后续再require该路径，就直接从内存里取出，不需要重新执行对应的文件

特点
commonJS是服务器编程范式，因为服务器上所有文件都在硬盘里，通过同步加载的方式即可，所以该规范是同步加载规范。同时它是在运行时加载，也就是你可以在require里拼接变量，在加载时会自动识别出最终的实际路径

AMD
定义
define(module, [dep1, dep2], callback)

机制
通过require加载时，它会先加载对应的依赖，等依赖资源加载完之后，会执行回调函数，将依赖作为入参，执行对应的业务逻辑

特点
AMD机制是浏览器编程范式，它是在客户端使用的，由于资源都是在服务器上，所以它是异步加载。同时，它最大的特点是强调依赖前置。

CMD
定义
机制和AMD类似，最大的区别就是CMD强调延迟加载，对应的依赖等到回调函数里执行具体依赖语句，才会去加载，但是AMD在后续版本里也支持了延迟加载的写法

机制
同上

特点
同上

UMD
定义
CommonJS、AMD、CMD并行的状态下，就需要一种方案能够兼容他们，这样我们在开发时，
就不需要再去考虑依赖模块所遵循的规范了，而UMD的出现就是为了解决这个问题。

ES6
定义
通过import引入依赖，通过export导出依赖

机制
ES6的模块机制在依赖模块时并不会先去预加载整个脚本，而是生成一个只读引用，并且静态解析依赖，等到执行代码时，再去依赖里取出实际需要的模块

特点
编译时加载，不允许在里边引用变量，必须为真实的文件路径。可以通过调用import()语句，会生成一个promise去加载对应的文件，这样子就是运行时加载，可以在路径里边编写变量