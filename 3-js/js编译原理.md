# 编译步骤类似传统编译语言, 某些情况更复杂(JIT).

- 分词/词法分析.
- 解析/语法分析. (AST, 抽象语法树)
- 生成代码.


# 什么是作用域?

作用域, 负责收集并维护由所有声明的标识符(变量)组成的一些列查询,并实施一套非常严格的规则,确定当前执行的代码对这些标识符的访问权限.

# 编译器查询

- LHS | RHS : 赋值操作的左侧或非左侧.
- 当变量出现在赋值操作的左侧时进行LHS.
  
- RHS找不到变量报错ReferenceError.
- 严格模式, LHS变量不存在报错TypeError.

# 词法作用域

- 作用域嵌套
- 全局作用域.
- 当前作用域.


# 基于作用域, 实现内部隐藏

- 软件设计原则: 从最小特权原则中引申出来的, 也叫最小特权或最小暴露原则.
- 例如设计模块或API.
- 规避变量名冲突, 例如第三方库等.


# 解决函数名污染所在的作用域

- (function)() 立即执行函数, 将函数名封装在表达式的作用域内部.
- 匿名函数表达式.
  - 匿名函数在栈追踪中不会显示出来有意义的函数名, 调试变得困难.
  - 没有函数名,当函数需要引用自身时只能使用已经过期的arguments.callee引用,例如递归,事件监听解绑自身.


# 块作用域

```js
for (let i = 0; i < 10; i++) {
  console.log(i)
}
```
- 块作用域是一个用来对之前的最小授权原则进行扩展的工具,将代码从在函数中隐藏信息扩展为在块中隐藏信息.
- with. with从对象中创建出的作用域仅在with声明中而非外部作用域中有效.
- try/catch, catch分局会创建一个块作用域, 其中声明的变量仅在catch内部有效.err
- let.let关键字可以将变量绑定到所在的任意作用域中(通常是{...}内部.). 即let为其声明的变量隐式地劫持了所在的块作用域.
  - ```js
      var foo = true
      if(foo){
        let bar = foo * 2
        bar = something(bar)
        console.log(bar)
      }
      console.log(bar)  //ReferenceError
    ```
- const, 也可用来创建块作用域.


# 任何声明在某个作用域内的变量, 都将附属于这个作用域.
- var变量和函数的声明提升.
- 编译器先声明,后赋值.
- 只有声明本身会被提升, 而赋值或者其他运行逻辑会留在原地.
  ```js
  console.log(a)  // undefined
  var a = 2
  // var = func 函数会报错TypeError
  ```
- 函数优先.
  ```js
  foo(); // 1
  var foo;
  function foo(){
    console.log(1)
  } 
  foo = function(){
    console.log(2)
  }
  foo() // 2  // 后面的函数声明覆盖前面的
  ```